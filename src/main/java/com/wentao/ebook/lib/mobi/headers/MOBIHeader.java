package com.wentao.ebook.lib.mobi.headers;

import com.wentao.ebook.annotation.Offset;
import com.wentao.ebook.common.ByteUtils;

import java.io.InputStream;
import java.lang.reflect.Field;

public class MOBIHeader {
    /**
     * the characters M O B I
     */
    @Offset(4)
    private String identifier;
    /**
     * the length of the MOBI header, including the previous 4 bytes
     */
    @Offset(4)
    private long headerLength = -1;
    /**
     * The kind of Mobipocket file this is
     * 2 Mobipocket Book
     *
     * 3 PalmDoc Book
     *
     * 4 Audio
     *
     * 232 mobipocket? generated by kindlegen1.2
     *
     *             248 KF8: generated by kindlegen2
     *
     * 257 News
     *
     * 258 News_Feed
     *
     * 259 News_Magazine
     *
     * 513 PICS
     *
     * 514 WORD
     *
     * 515 XLS
     * 516 PPT
     * 517 TEXT
     * 518 HTML
     */
    @Offset(4)
    private long mobiType;
    /**
     * 1252 = CP1252 (WinLatin1); 65001 = UTF-8
     */
    @Offset(4)
    private long textEncoding;

    /**
     * Some kind of unique ID number (random?)
     */
    @Offset(4)
    private long uniqueID;

    /**
     * Version of the Mobipocket format used in this file.
     */
    @Offset(4)
    private long fileVersion;

    /**
     * Section number of orthographic meta index. 0xFFFFFFFF if index is not available.
     */
    @Offset(4)
    private long ortographicIndex;

    /**
     * Section number of inflection meta index. 0xFFFFFFFF if index is not available.
     */
    @Offset(4)
    private long inflectionIndex;

    /**
     * 	0xFFFFFFFF if index is not available.
     */
    @Offset(4)
    private long indexNames;

    /**
     * 	0xFFFFFFFF if index is not available.
     */
    @Offset(4)
    private long indexKeys;

    /**
     * 	Section number of extra 0 meta index. 0xFFFFFFFF if index is not available.
     */
    @Offset(4)
    private long extraIndex0;


    /**
     * 	Section number of extra 1 meta index. 0xFFFFFFFF if index is not available.
     */
    @Offset(4)
    private long extraIndex1;
    
    /**
     * 	Section number of extra 2 meta index. 0xFFFFFFFF if index is not available.
     */
    @Offset(4)
    private long extraIndex2;
    /**
     * 	Section number of extra 3 meta index. 0xFFFFFFFF if index is not available.
     */
    @Offset(4)
    private long extraIndex3;
    /**
     * 	Section number of extra 4 meta index. 0xFFFFFFFF if index is not available.
     */
    @Offset(4)
    private long extraIndex4;
    /**
     * 	Section number of extra 5 meta index. 0xFFFFFFFF if index is not available.
     */
    @Offset(4)
    private long extraIndex5;

    /**
     * 	First record number (starting with 0) that's not the book's text
     */
    @Offset(4)
    private long firstNonBookIndex;

    /**
     * 	Offset in record 0 (not from start of file) of the full name of the book
     */
    @Offset(4)
    private long fullNameOffset;

    /**
     * in bytes of the full name of the book
     */
    @Offset(4)
    private long fullNameLength;

    /**
     * Book locale code. Low byte is main language 09= English, next byte is dialect, 08 = British, 04 = US. Thus US English is 1033, UK English is 2057.
     */
    @Offset(4)
    private long locale;

    /**
     * Input language for a dictionary
     */
    @Offset(4)
    private long inputLanguage;

    /**
     * Output language for a dictionary
     */
    @Offset(4)
    private long outputLanguage;

    /**
     * Minimum mobipocket version support needed to read this file.
     */
    @Offset(4)
    private long minVersion;

    /**
     * First record number (starting with 0) that contains an image. Image records should be sequential.
     */
    @Offset(4)
    private long firstImageIndex;

    /**
     * The record number of the first huffman compression record.
     */
    @Offset(4)
    private long huffmanRecordOffset;

    /**
     * The number of huffman compression records.
     */
    @Offset(4)
    private long huffmanRecordCount;

    /**
     * The record number of huffman table.
     */
    @Offset(4)
    private long huffmanTableOffset;
    /**
     * The Length of huffman table.
     */
    @Offset(4)
    private long huffmanTableLength;

    /**
     * bitfield. if bit 6 (0x40) is set, then there's an EXTH record
     */
    @Offset(4)
    private long exthFlags;
    /**
     * 32 unknown bytes, if MOBI is long enough
     */
    @Offset(32)
    private String unknownBytes;

    /**
     * 4 unknown bytes, Use 0xFFFFFFFF
     */
    @Offset(4)
    private long unknownBytes2;

    /**
     * Offset to DRM key info in DRMed files. 0xFFFFFFFF if no DRM
     */
    @Offset(4)
    private long drmOffset;


    /**
     * Number of entries in DRM info. 0xFFFFFFFF if no DRM
     */
    @Offset(4)
    private long drmCount;

    /**
     * Number of bytes in DRM info.
     */
    @Offset(4)
    private long drmSize;

    /**
     * Some flags concerning the DRM info.
     */
    @Offset(4)
    private String drmFlags;

    /**
     * Bytes to the end of the MOBI header, including the following if the header length >= 228 (244 from start of record).
     *     Use 0x0000000000000000.
     */
    @Offset(8)
    private long unknownBytes3;

    /**
     * Number of first text record. Normally 1.
     */
    @Offset(2)
    private long firstContentRecordNumber;

    /**
     * Number of last image record or number of last text record if it contains no images. Includes Image, DATP, HUFF, DRM.
     */
    @Offset(2)
    private long lastContentRecordNumber;

    /**
     * Use 0x00000001.
     */
    @Offset(4)
    private long unknownBytes4;
    /**
     * FCIS record number
     */
    @Offset(4)
    private long fcisRecordNumber;
    /**
     * (FCIS record count?)	Use 0x00000001.
     */
    @Offset(4)
    private long unknownBytes5;
    /**
     * FLIS record number
     */
    @Offset(4)
    private long flisRecordNumber;
    /**
     * (FLIS record count?)	Use 0x00000001.
     */
    @Offset(4)
    private long unknownBytes6;

    /**
     * Use 0x0000000000000000.
     */
    @Offset(8)
    private long unknownBytes7;

    /**
     *  Use 0xFFFFFFFF.
     */
    @Offset(4)
    private long unknownBytes8;


    /**
     *  Use 0x00000000.
     */
    @Offset(4)
    private long  firstCompilationDataSectionCount;

    /**
     *  Use 0xFFFFFFFF.
     */
    @Offset(4)
    private long  numberOfCompilationDataSections;

    /**
     *  Use 0xFFFFFFFF.
     */
    @Offset(4)
    private long unknownBytes9;

    /**
     *  A set of binary flags, some of which indicate extra data at the end of each text block. 
     *  This only seems to be valid for Mobipocket format version 5 and 6 (and higher?), when 
     *  the header length is 228 (0xE4) or 232 (0xE8)
     *     bit 1 (0x1): <extra multibyte bytes><size>
     *     bit 2 (0x2): <TBS indexing description of this HTML record><size>
     *     bit 3 (0x4): <uncrossable breaks><size>
     *  Setting bit 2 (0x2) disables <guide><reference type="start"> functionality.
     */
    @Offset(4)
    private String extraRecordDataFlags;

    /**
     *  (If not 0xFFFFFFFF)The record number of the first INDX record created from an ncx file.
     */
    @Offset(4)
    private long indxRecordOffset;
    /**
     *  0xFFFFFFFF In new MOBI file, the MOBI header length is 256, skip this to EXTH header.
     */
    @Offset(4)
    private long unknownBytes10;

    /**
     *  0xFFFFFFFF In new MOBI file, the MOBI header length is 256, skip this to EXTH header.
     */
    @Offset(4)
    private long unknownBytes11;
    /**
     *  0xFFFFFFFF In new MOBI file, the MOBI header length is 256, skip this to EXTH header.
     */
    @Offset(4)
    private long unknownBytes12;
    /**
     *  0xFFFFFFFF In new MOBI file, the MOBI header length is 256, skip this to EXTH header.
     */
    @Offset(4)
    private long unknownBytes13;
    /**
     *  0xFFFFFFFF In new MOBI file, the MOBI header length is 256, skip this to EXTH header.
     */
    @Offset(4)
    private long unknownBytes14;

    /**
     *  In new MOBI file, the MOBI header length is 256, skip this to EXTH header, MOBI Header 
     *  length 256, and add 12 bytes from PalmDOC Header so this index is 268.
     */
    @Offset(4)
    private long unknownBytes15;

    private int readLength = 0;
    public void read(InputStream in) throws Exception {
        Field[] fields = this.getClass().getDeclaredFields();
        for (Field field : fields) {
            field.setAccessible(true);
            if(readLength==this.headerLength){
                return;
            }
            Offset offsetAnnotation = field.getAnnotation(Offset.class);
            if (offsetAnnotation != null) {
                int offset = offsetAnnotation.value();
                readLength+=offset;
                byte[] bytes = new byte[offset];
                assert in.read(bytes) == offset;
                if (field.getType() == String.class) {
                    field.set(this, new String(bytes).trim());
                } else if (field.getType() == long.class) {
                    field.set(this, ByteUtils.bytes2long(bytes));
                }
            }
        }
    }

    public String getIdentifier() {
        return identifier;
    }

    public long getHeaderLength() {
        return headerLength;
    }

    public long getMobiType() {
        return mobiType;
    }

    public long getTextEncoding() {
        return textEncoding;
    }

    public long getUniqueID() {
        return uniqueID;
    }

    public long getFileVersion() {
        return fileVersion;
    }

    public long getOrtographicIndex() {
        return ortographicIndex;
    }

    public long getInflectionIndex() {
        return inflectionIndex;
    }

    public long getIndexNames() {
        return indexNames;
    }

    public long getIndexKeys() {
        return indexKeys;
    }

    public long getExtraIndex0() {
        return extraIndex0;
    }

    public long getExtraIndex1() {
        return extraIndex1;
    }

    public long getExtraIndex2() {
        return extraIndex2;
    }

    public long getExtraIndex3() {
        return extraIndex3;
    }

    public long getExtraIndex4() {
        return extraIndex4;
    }

    public long getExtraIndex5() {
        return extraIndex5;
    }

    public long getFirstNonBookIndex() {
        return firstNonBookIndex;
    }

    public long getFullNameOffset() {
        return fullNameOffset;
    }

    public long getFullNameLength() {
        return fullNameLength;
    }

    public long getLocale() {
        return locale;
    }

    public long getInputLanguage() {
        return inputLanguage;
    }

    public long getOutputLanguage() {
        return outputLanguage;
    }

    public long getMinVersion() {
        return minVersion;
    }

    public long getFirstImageIndex() {
        return firstImageIndex;
    }

    public long getHuffmanRecordOffset() {
        return huffmanRecordOffset;
    }

    public long getHuffmanRecordCount() {
        return huffmanRecordCount;
    }

    public long getHuffmanTableOffset() {
        return huffmanTableOffset;
    }

    public long getHuffmanTableLength() {
        return huffmanTableLength;
    }

    public long getExthFlags() {
        return exthFlags;
    }

    public long getDrmOffset() {
        return drmOffset;
    }

    public long getDrmCount() {
        return drmCount;
    }

    public long getDrmSize() {
        return drmSize;
    }

    public String getDrmFlags() {
        return drmFlags;
    }

    public long getFirstContentRecordNumber() {
        return firstContentRecordNumber;
    }

    public long getLastContentRecordNumber() {
        return lastContentRecordNumber;
    }

    public long getFcisRecordNumber() {
        return fcisRecordNumber;
    }

    public long getFlisRecordNumber() {
        return flisRecordNumber;
    }

    public long getFirstCompilationDataSectionCount() {
        return firstCompilationDataSectionCount;
    }

    public long getNumberOfCompilationDataSections() {
        return numberOfCompilationDataSections;
    }

    public String getExtraRecordDataFlags() {
        return extraRecordDataFlags;
    }

    public long getIndxRecordOffset() {
        return indxRecordOffset;
    }

    public int getReadLength() {
        return readLength;
    }
    
}
